---
layout: post
title: "WIP: On Modeling Oil"
page_title: "WIP: Instructions on modeling oil supply chains in Wolfram Mathematica"
categories:
  - energy
  - oil&gas
  - modeling
author:
- ਪ੍ਰਭਚਿੰਤਨਰੰਧਾਵਾ | Prab Randhawa
meta: "Kant, Hegel, Schopenhauer, Nietzsche and their views on reality, knowledge, reason, will, and the human condition."
---

## Introduction

In the face of ever-increasing global demand for energy, understanding how resources (oil, gas, water, etc.) flow through distribution networks is critical. This blog post presents a **detailed, step-by-step** approach to modeling the distribution of oil from central reserves to various regional and local storage hubs in *Wolfram Mathematica*. The model reflects hierarchical systems with potential feedback loops, pipeline constraints, friction, and demand mechanisms.

By **integrating theoretical, computational, and philosophical underpinnings**, we create a refined framework that goes beyond simplistic representations of Earth’s reserves. This post improves upon an earlier outline, rectifying oversimplified assumptions and providing a more epistemologically sound, falsifiable modeling structure.

---

## 1. Motivations and Goals

1. **Realism**  
   - Capture the complexity of **multiple reservoirs** (or at least acknowledge the possibility) rather than treating Earth as a single, uniform sphere.  
   - Use **graph theory** to represent real-world, possibly **asymmetric** pipeline networks.

2. **Technical Rigor**  
   - Incorporate **capacity constraints**, **frictional losses**, and **demand** dynamics.  
   - Allow **discrete or continuous** simulations that can be validated and falsified.

3. **Philosophical Grounding**  
   - Embrace **Popper’s falsifiability** by permitting comparison with real-world data.  
   - Maintain **transparency** in simplifying assumptions to understand where the model might fail or need refinement.

Overall, this post aims to provide both **conceptual clarity** and **practical Mathematica code** that you can tailor to your specific research or educational needs.

---

## 2. High-Level Model Overview

Below is a concise breakdown of the revised model structure:

1. **Reservoirs**  
   - One or more large reservoirs (e.g., “Earth Main” and “Secondary”) representing significant resource stores.  
   - Each reservoir is parameterized by **capacity** (or volume), **current volume**, and **pressure**.

2. **Distribution Nodes** (Tanks)  
   - Conceptualized in layers (major hubs, sub-regional hubs, local tanks), but **with possible feedback** loops (not strictly top-down).  
   - Each node has properties such as **Capacity**, **Volume**, **Demand**, and **Pressure**.

3. **Pipelines (Edges)**  
   - Represented by a graph structure in Mathematica, with **MaxFlow** capacity, **Resistance** (friction or other limitations), and optional length/diameter.  
   - Flow is governed by **pressure difference** and **resistance** constraints, capped at a maximum flow rate.

4. **Flow Equations**  
   - **Discrete-time** or **continuous ODE** approach.  
   - Accounting for **inflow**, **outflow**, **demand**, and potential losses.

---

## 3. Philosophical and Epistemological Considerations

### 3.1 Falsifiability and Validation

- **Falsifiable Predictions**: The model’s flow rates and storage volumes can be compared to real data (where available). Significant discrepancies indicate a need to refine assumptions (e.g., friction constants, demand patterns).
- **Transparency in Abstractions**: We explicitly state our simplified assumptions (e.g., ignoring elevation changes, compressibility, or regional geological complexities). This openness allows others to see how the model might break down and to propose enhancements.

### 3.2 Iterative Refinement

- **Popperian Feedback Loop**: Begin with a simpler representation (few tanks, uniform friction) and refine based on new data or theoretical insights.  
- **Open-Ended Extensions**: Add more layers, incorporate real pipeline geospatial data, or link to external systems (e.g., electricity or production rates) as the model matures.

## 4. Implementation in Mathematica

Below is a **sample code structure** illustrating how to set up nodes, edges, and flow dynamics. It starts with simplified assumptions and can be extended to more sophisticated behaviors.

### 4.1 Define Node (Tank) and Reservoir Data

```wolfram
(* Each node stores capacity, current volume, base pressure, demand, and coordinates for visualization *)
nodeData = <|
  "Central" -> <|
    "Capacity" -> Infinity,
    "Volume"   -> 1000,       (* Arbitrary initial volume in 'Central' reservoir *)
    "Pressure" -> 5,          (* Base pressure, for demonstration *)
    "Demand"   -> 0,
    "Coordinates" -> {0, 0, 0} (* 3D location, if needed for visualization *)
  |>,
  "TankA"   -> <|
    "Capacity" -> 300,
    "Volume"   -> 0,
    "Pressure" -> 0,
    "Demand"   -> 10,         (* Demand units per time step *)
    "Coordinates" -> {2, 0, 0}
  |>,
  "TankB"   -> <|
    "Capacity" -> 200,
    "Volume"   -> 0,
    "Pressure" -> 0,
    "Demand"   -> 5,
    "Coordinates" -> {4, 1, 0}
  |>
|>;
```

### 4.2 Define Pipeline (Edge) Data

```wolfram
(* Each pipeline has a maximum flow capacity and a resistance value *)
edgeData = <|
  {"Central", "TankA"} -> <|"MaxFlow" -> 10, "Resistance" -> 1|>,
  {"TankA",   "TankB"} -> <|"MaxFlow" -> 5,  "Resistance" -> 2|>
|>;
```

Note: In practical scenarios, you may store distances, diameters, or friction coefficients (like Darcy–Weisbach) and compute an effective resistance.

### 4.3 Flow Equation (Discrete Time)

```wolfram
(* A simple function that computes flow from node i to node j *)
flowFunction[vI_, vJ_, capI_, capJ_, r_, maxFlow_] :=
  Module[{pI, pJ, potentialFlow},
    (* Example: Pressure is a function of fill fraction.
       basePressure = 1, scaled by volume/capacity. *)
    pI = 1 + (vI / capI);
    pJ = 1 + (vJ / capJ);
    
    (* Flow ~ (P_i - P_j)/Resistance, clamped by maxFlow and >= 0 *)
    potentialFlow = (pI - pJ)/r;
    Return[Clip[potentialFlow, {0, maxFlow}]];
  ];

timeStep = 0.1;  (* Simulation time step *)

(* Update volumes for all nodes based on pipeline flow and demand *)
updateVolumes[nodeData_, edgeData_] :=
  Module[{newData = nodeData},
    (* For each edge, compute flow and update volumes *)
    Do[
      With[{i = e[[1, 1]], j = e[[1, 2]], props = e[[2]]},
        (* Retrieve volumes and capacities *)
        vI   = newData[i, "Volume"];
        vJ   = newData[j, "Volume"];
        capI = newData[i, "Capacity"];
        capJ = newData[j, "Capacity"];
        r    = props["Resistance"];
        mf   = props["MaxFlow"];
        
        (* Calculate flow from i -> j *)
        q = flowFunction[vI, vJ, capI, capJ, r, mf];
  